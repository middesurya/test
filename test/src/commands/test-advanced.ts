/**
 * Advanced Testing Commands
 * Mock server generation, chaos testing, and spec compliance testing
 */

import { Command } from 'commander';
import ora from 'ora';
import path from 'path';
import chalk from 'chalk';
import { promises as fs } from 'fs';

interface MockOptions {
  output?: string;
  port?: string;
  tools?: string;
}

interface ChaosOptions {
  duration?: string;
  failureRate?: string;
  latency?: string;
  scenarios?: string;
}

interface CompatOptions {
  specVersion?: string;
  verbose?: boolean;
  json?: boolean;
}

// Main test command with subcommands
export const testCommand = new Command('test')
  .description('Advanced testing utilities');

// ===========================================
// Mock Server Generator
// ===========================================

testCommand
  .command('mock')
  .description('Generate mock MCP server for client testing')
  .argument('[path]', 'Path to MCP server project', '.')
  .option('-o, --output <file>', 'Output file for mock server', 'mock-server.ts')
  .option('-p, --port <port>', 'Port for mock server', '3001')
  .option('--tools <tools>', 'Comma-separated list of tools to mock')
  .action(async (projectPath: string, options: MockOptions) => {
    const resolvedPath = path.resolve(process.cwd(), projectPath);
    const spinner = ora('Generating mock server...').start();

    try {
      // Read project config
      const packageJsonPath = path.join(resolvedPath, 'package.json');
      let projectName = 'mock-mcp-server';

      try {
        const packageJson = JSON.parse(await fs.readFile(packageJsonPath, 'utf-8'));
        projectName = packageJson.name || projectName;
      } catch {
        // Use default name
      }

      // Generate mock server code
      const mockCode = generateMockServerCode(projectName, options);

      // Write output
      const outputPath = path.join(resolvedPath, options.output || 'mock-server.ts');
      await fs.writeFile(outputPath, mockCode);

      spinner.succeed(`Mock server generated at ${outputPath}`);
      console.log(chalk.cyan('\nUsage:'));
      console.log(`  npx ts-node ${options.output || 'mock-server.ts'}`);
      console.log(`  # Server will run at http://localhost:${options.port || '3001'}`);
    } catch (error) {
      spinner.fail('Failed to generate mock server');
      console.error(chalk.red((error as Error).message));
      process.exit(1);
    }
  });

function generateMockServerCode(projectName: string, options: MockOptions): string {
  const port = options.port || '3001';
  const tools = options.tools?.split(',').map(t => t.trim()) || ['example_tool'];

  return `/**
 * Mock MCP Server for ${projectName}
 * Generated by mcp-gen test:mock
 */

import http from 'http';

const PORT = ${port};

interface MockToolResponse {
  content: { type: string; text: string }[];
}

// Mock tool implementations
const mockTools: Record<string, (args: unknown) => MockToolResponse> = {
${tools.map(tool => `  '${tool}': (args) => ({
    content: [{ type: 'text', text: JSON.stringify({ mock: true, tool: '${tool}', args }) }]
  })`).join(',\n')}
};

const server = http.createServer((req, res) => {
  // CORS headers
  res.setHeader('Access-Control-Allow-Origin', '*');
  res.setHeader('Access-Control-Allow-Methods', 'POST, GET, OPTIONS');
  res.setHeader('Access-Control-Allow-Headers', 'Content-Type');

  if (req.method === 'OPTIONS') {
    res.writeHead(204);
    res.end();
    return;
  }

  if (req.url === '/health') {
    res.writeHead(200, { 'Content-Type': 'application/json' });
    res.end(JSON.stringify({ status: 'ok', mock: true }));
    return;
  }

  if (req.url === '/mcp' && req.method === 'POST') {
    let body = '';
    req.on('data', chunk => body += chunk);
    req.on('end', () => {
      try {
        const { method, params } = JSON.parse(body);

        if (method === 'tools/list') {
          res.writeHead(200, { 'Content-Type': 'application/json' });
          res.end(JSON.stringify({
            tools: Object.keys(mockTools).map(name => ({
              name,
              description: \`Mock implementation of \${name}\`,
              inputSchema: { type: 'object', properties: {}, additionalProperties: true }
            }))
          }));
          return;
        }

        if (method === 'tools/call') {
          const tool = mockTools[params.name];
          if (tool) {
            res.writeHead(200, { 'Content-Type': 'application/json' });
            res.end(JSON.stringify(tool(params.arguments)));
            return;
          }
          res.writeHead(404, { 'Content-Type': 'application/json' });
          res.end(JSON.stringify({ error: \`Tool not found: \${params.name}\` }));
          return;
        }

        res.writeHead(400, { 'Content-Type': 'application/json' });
        res.end(JSON.stringify({ error: 'Unknown method' }));
      } catch (error) {
        res.writeHead(500, { 'Content-Type': 'application/json' });
        res.end(JSON.stringify({ error: 'Internal server error' }));
      }
    });
    return;
  }

  res.writeHead(404);
  res.end('Not Found');
});

server.listen(PORT, () => {
  console.log(\`Mock MCP server running at http://localhost:\${PORT}\`);
  console.log('Available tools:', Object.keys(mockTools).join(', '));
});
`;
}

// ===========================================
// Chaos Testing
// ===========================================

testCommand
  .command('chaos')
  .description('Run chaos tests (dependency failures, latency)')
  .argument('[path]', 'Path to MCP server project', '.')
  .option('-d, --duration <seconds>', 'Test duration in seconds', '60')
  .option('-f, --failure-rate <percent>', 'Failure injection rate (0-100)', '10')
  .option('-l, --latency <ms>', 'Injected latency in milliseconds', '0')
  .option('--scenarios <list>', 'Comma-separated chaos scenarios')
  .action(async (projectPath: string, options: ChaosOptions) => {
    const resolvedPath = path.resolve(process.cwd(), projectPath);
    const spinner = ora('Running chaos tests...').start();

    try {
      const duration = parseInt(options.duration || '60', 10);
      const failureRate = parseInt(options.failureRate || '10', 10);
      const latency = parseInt(options.latency || '0', 10);
      const scenarios = options.scenarios?.split(',').map(s => s.trim()) || ['random_failure'];

      spinner.text = `Chaos test: ${scenarios.join(', ')} for ${duration}s`;

      // Generate chaos test configuration
      const chaosConfig = {
        duration,
        failureRate,
        latency,
        scenarios,
        projectPath: resolvedPath,
        startTime: new Date().toISOString(),
      };

      // Write chaos config
      const configPath = path.join(resolvedPath, '.chaos-config.json');
      await fs.writeFile(configPath, JSON.stringify(chaosConfig, null, 2));

      spinner.succeed('Chaos test configuration generated');
      console.log(chalk.cyan('\nChaos Test Configuration:'));
      console.log(`  Duration: ${duration}s`);
      console.log(`  Failure Rate: ${failureRate}%`);
      console.log(`  Latency Injection: ${latency}ms`);
      console.log(`  Scenarios: ${scenarios.join(', ')}`);
      console.log(chalk.yellow('\nTo run chaos tests:'));
      console.log('  npm run test:chaos');
      console.log('  # Or with chaos-monkey:');
      console.log('  npx chaos-monkey --config .chaos-config.json');
    } catch (error) {
      spinner.fail('Failed to set up chaos tests');
      console.error(chalk.red((error as Error).message));
      process.exit(1);
    }
  });

// ===========================================
// Spec Compatibility Testing
// ===========================================

testCommand
  .command('compat')
  .description('Validate MCP spec compliance')
  .argument('[path]', 'Path to MCP server project', '.')
  .option('--spec-version <version>', 'MCP spec version to test against', '2025-03-26')
  .option('-v, --verbose', 'Show detailed results')
  .option('--json', 'Output results as JSON')
  .action(async (projectPath: string, options: CompatOptions) => {
    const resolvedPath = path.resolve(process.cwd(), projectPath);
    const spinner = options.json ? null : ora('Running compatibility tests...').start();

    try {
      const specVersion = options.specVersion || '2025-03-26';
      const results = await runCompatibilityTests(resolvedPath, specVersion);

      if (options.json) {
        console.log(JSON.stringify(results, null, 2));
      } else {
        if (results.passed) {
          spinner?.succeed(`Compatibility check passed (MCP ${specVersion})`);
        } else {
          spinner?.fail(`Compatibility issues found`);
        }

        console.log(chalk.cyan('\nCompatibility Results:'));
        console.log(`  Spec Version: ${specVersion}`);
        console.log(`  Checks Passed: ${results.passedCount}/${results.totalCount}`);

        if (options.verbose || !results.passed) {
          console.log(chalk.cyan('\nDetails:'));
          for (const check of results.checks) {
            const icon = check.passed ? chalk.green('✓') : chalk.red('✗');
            console.log(`  ${icon} ${check.name}: ${check.message}`);
          }
        }
      }

      process.exit(results.passed ? 0 : 1);
    } catch (error) {
      if (spinner) {
        spinner.fail('Compatibility test failed');
        console.error(chalk.red((error as Error).message));
      } else {
        console.log(JSON.stringify({ error: (error as Error).message }));
      }
      process.exit(1);
    }
  });

interface CompatibilityResult {
  passed: boolean;
  passedCount: number;
  totalCount: number;
  specVersion: string;
  checks: { name: string; passed: boolean; message: string }[];
}

async function runCompatibilityTests(projectPath: string, specVersion: string): Promise<CompatibilityResult> {
  const checks: { name: string; passed: boolean; message: string }[] = [];

  // Check package.json for SDK version
  try {
    const packageJsonPath = path.join(projectPath, 'package.json');
    const packageJson = JSON.parse(await fs.readFile(packageJsonPath, 'utf-8'));
    const sdkVersion = packageJson.dependencies?.['@modelcontextprotocol/sdk'];

    if (sdkVersion) {
      checks.push({
        name: 'MCP SDK',
        passed: true,
        message: `SDK version ${sdkVersion} found`
      });
    } else {
      checks.push({
        name: 'MCP SDK',
        passed: false,
        message: 'MCP SDK not found in dependencies'
      });
    }
  } catch {
    checks.push({
      name: 'MCP SDK',
      passed: false,
      message: 'Could not read package.json'
    });
  }

  // Check for required files
  const requiredFiles = [
    { path: 'src/index.ts', name: 'Entry point' },
    { path: 'tsconfig.json', name: 'TypeScript config' },
  ];

  for (const file of requiredFiles) {
    try {
      await fs.access(path.join(projectPath, file.path));
      checks.push({
        name: file.name,
        passed: true,
        message: `${file.path} exists`
      });
    } catch {
      checks.push({
        name: file.name,
        passed: false,
        message: `${file.path} not found`
      });
    }
  }

  // Check for tool definitions
  try {
    const srcIndex = path.join(projectPath, 'src', 'index.ts');
    const content = await fs.readFile(srcIndex, 'utf-8');

    if (content.includes('ListToolsRequestSchema') || content.includes('tools')) {
      checks.push({
        name: 'Tool definitions',
        passed: true,
        message: 'Tool handlers found'
      });
    } else {
      checks.push({
        name: 'Tool definitions',
        passed: false,
        message: 'No tool handlers found'
      });
    }

    // Check for proper error handling
    if (content.includes('catch') || content.includes('.catch')) {
      checks.push({
        name: 'Error handling',
        passed: true,
        message: 'Error handling present'
      });
    } else {
      checks.push({
        name: 'Error handling',
        passed: false,
        message: 'Missing error handling'
      });
    }
  } catch {
    checks.push({
      name: 'Tool definitions',
      passed: false,
      message: 'Could not read src/index.ts'
    });
  }

  const passedCount = checks.filter(c => c.passed).length;

  return {
    passed: passedCount === checks.length,
    passedCount,
    totalCount: checks.length,
    specVersion,
    checks
  };
}

// Shorthand commands
export const testMockCommand = new Command('test:mock')
  .description('Generate mock MCP server (shorthand)')
  .argument('[path]', 'Path to MCP server project', '.')
  .option('-o, --output <file>', 'Output file', 'mock-server.ts')
  .option('-p, --port <port>', 'Port', '3001')
  .option('--tools <tools>', 'Tools to mock')
  .action(async (projectPath: string, options: MockOptions) => {
    const mockCmd = testCommand.commands.find(c => c.name() === 'mock');
    await mockCmd?.parseAsync([projectPath,
      ...(options.output ? ['-o', options.output] : []),
      ...(options.port ? ['-p', options.port] : []),
      ...(options.tools ? ['--tools', options.tools] : [])
    ], { from: 'user' });
  });

export const testChaosCommand = new Command('test:chaos')
  .description('Run chaos tests (shorthand)')
  .argument('[path]', 'Path to MCP server project', '.')
  .option('-d, --duration <seconds>', 'Duration', '60')
  .option('-f, --failure-rate <percent>', 'Failure rate', '10')
  .option('-l, --latency <ms>', 'Latency', '0')
  .action(async (projectPath: string, options: ChaosOptions) => {
    const chaosCmd = testCommand.commands.find(c => c.name() === 'chaos');
    await chaosCmd?.parseAsync([projectPath,
      ...(options.duration ? ['-d', options.duration] : []),
      ...(options.failureRate ? ['-f', options.failureRate] : []),
      ...(options.latency ? ['-l', options.latency] : [])
    ], { from: 'user' });
  });

export const testCompatCommand = new Command('test:compat')
  .description('Validate MCP spec compliance (shorthand)')
  .argument('[path]', 'Path to MCP server project', '.')
  .option('--spec-version <version>', 'Spec version', '2025-03-26')
  .option('-v, --verbose', 'Verbose output')
  .option('--json', 'JSON output')
  .action(async (projectPath: string, options: CompatOptions) => {
    const compatCmd = testCommand.commands.find(c => c.name() === 'compat');
    await compatCmd?.parseAsync([projectPath,
      ...(options.specVersion ? ['--spec-version', options.specVersion] : []),
      ...(options.verbose ? ['-v'] : []),
      ...(options.json ? ['--json'] : [])
    ], { from: 'user' });
  });
