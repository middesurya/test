/**
 * OpenTelemetry Tracer Configuration
 * CRITICAL: This module must be imported BEFORE any other modules
 */

import { NodeSDK } from '@opentelemetry/sdk-node';
import { getNodeAutoInstrumentations } from '@opentelemetry/auto-instrumentations-node';
import { OTLPTraceExporter } from '@opentelemetry/exporter-trace-otlp-http';
import { Resource } from '@opentelemetry/resources';
import { SemanticResourceAttributes } from '@opentelemetry/semantic-conventions';
import { trace, SpanStatusCode, Span, context, SpanKind } from '@opentelemetry/api';

const serviceName = process.env.OTEL_SERVICE_NAME || '{{projectName}}';
const otlpEndpoint = process.env.OTEL_EXPORTER_OTLP_ENDPOINT || 'http://localhost:4318';

// Create OTLP exporter (not deprecated Jaeger native)
const traceExporter = new OTLPTraceExporter({
  url: `${otlpEndpoint}/v1/traces`,
});

// Initialize SDK
const sdk = new NodeSDK({
  resource: new Resource({
    [SemanticResourceAttributes.SERVICE_NAME]: serviceName,
    [SemanticResourceAttributes.SERVICE_VERSION]: '{{version}}',
    'mcp.transport': 'stdio',
  }),
  traceExporter,
  instrumentations: [getNodeAutoInstrumentations()],
});

// Start SDK before application code
sdk.start();

// Graceful shutdown
process.on('SIGTERM', () => {
  sdk.shutdown()
    .then(() => console.log('Tracing terminated'))
    .catch((error) => console.error('Error terminating tracing', error))
    .finally(() => process.exit(0));
});

// Export tracer instance
export const tracer = trace.getTracer(serviceName);

/**
 * Create a span for MCP tool execution
 */
export function createToolSpan(toolName: string, attributes?: Record<string, string>): Span {
  return tracer.startSpan(`mcp.tool.${toolName}`, {
    kind: SpanKind.SERVER,
    attributes: {
      'mcp.tool.name': toolName,
      ...attributes,
    },
  });
}

/**
 * Wrapper for tracing async tool execution
 */
export async function withToolSpan<T>(
  toolName: string,
  fn: (span: Span) => Promise<T>,
  attributes?: Record<string, string>
): Promise<T> {
  const span = createToolSpan(toolName, attributes);

  try {
    const result = await context.with(trace.setSpan(context.active(), span), () => fn(span));
    span.setStatus({ code: SpanStatusCode.OK });
    return result;
  } catch (error) {
    span.setStatus({
      code: SpanStatusCode.ERROR,
      message: error instanceof Error ? error.message : 'Unknown error',
    });
    span.recordException(error as Error);
    throw error;
  } finally {
    span.end();
  }
}

/**
 * Add event to current span
 */
export function addSpanEvent(name: string, attributes?: Record<string, string>): void {
  const span = trace.getSpan(context.active());
  if (span) {
    span.addEvent(name, attributes);
  }
}

/**
 * Set attributes on current span
 */
export function setSpanAttributes(attributes: Record<string, string | number | boolean>): void {
  const span = trace.getSpan(context.active());
  if (span) {
    span.setAttributes(attributes);
  }
}

export { sdk, SpanStatusCode, SpanKind };
