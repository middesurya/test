"""
{{projectName}} - Enterprise MCP Server (Python)
With OAuth 2.0, rate limiting, and audit logging
"""

import os
import json
import logging
from datetime import datetime
from typing import Any
from functools import wraps

from fastmcp import FastMCP
from pydantic import BaseModel, Field

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

# Environment configuration
JWT_SECRET = os.getenv('JWT_SECRET', 'change-me-in-production')
RATE_LIMIT_REQUESTS = int(os.getenv('RATE_LIMIT_REQUESTS', '100'))
RATE_LIMIT_WINDOW = int(os.getenv('RATE_LIMIT_WINDOW', '60'))

# Initialize FastMCP server
mcp = FastMCP(
    name='{{projectName}}',
    version='{{version}}',
    description='{{projectDescription}}'
)

# ===========================================
# Rate Limiting
# ===========================================

class TokenBucket:
    """Simple token bucket rate limiter"""

    def __init__(self, max_tokens: int, refill_rate: float):
        self.max_tokens = max_tokens
        self.refill_rate = refill_rate
        self.tokens = max_tokens
        self.last_refill = datetime.now()

    def consume(self, tokens: int = 1) -> bool:
        now = datetime.now()
        elapsed = (now - self.last_refill).total_seconds()
        self.tokens = min(self.max_tokens, self.tokens + elapsed * self.refill_rate)
        self.last_refill = now

        if self.tokens >= tokens:
            self.tokens -= tokens
            return True
        return False


# Per-tenant rate limiters
rate_limiters: dict[str, TokenBucket] = {}


def get_rate_limiter(tenant_id: str) -> TokenBucket:
    if tenant_id not in rate_limiters:
        rate_limiters[tenant_id] = TokenBucket(
            max_tokens=RATE_LIMIT_REQUESTS,
            refill_rate=RATE_LIMIT_REQUESTS / RATE_LIMIT_WINDOW
        )
    return rate_limiters[tenant_id]


# ===========================================
# Audit Logging
# ===========================================

class AuditLog:
    """Structured audit logging"""

    @staticmethod
    def log(event: str, tenant_id: str, details: dict[str, Any] | None = None):
        log_entry = {
            'timestamp': datetime.utcnow().isoformat(),
            'event': event,
            'tenant_id': tenant_id,
            'details': details or {}
        }
        logger.info(f"AUDIT: {json.dumps(log_entry)}")


# ===========================================
# Tool Decorators
# ===========================================

def rate_limited(func):
    """Rate limit decorator for tools"""
    @wraps(func)
    async def wrapper(*args, **kwargs):
        tenant_id = kwargs.get('_tenant_id', 'default')
        limiter = get_rate_limiter(tenant_id)

        if not limiter.consume():
            raise Exception('Rate limit exceeded')

        return await func(*args, **kwargs)
    return wrapper


def audited(func):
    """Audit logging decorator for tools"""
    @wraps(func)
    async def wrapper(*args, **kwargs):
        tenant_id = kwargs.get('_tenant_id', 'default')
        tool_name = func.__name__

        AuditLog.log('tool_invocation', tenant_id, {'tool': tool_name})

        try:
            result = await func(*args, **kwargs)
            AuditLog.log('tool_success', tenant_id, {'tool': tool_name})
            return result
        except Exception as e:
            AuditLog.log('tool_error', tenant_id, {'tool': tool_name, 'error': str(e)})
            raise
    return wrapper


# ===========================================
# Tools
# ===========================================

class ExampleToolInput(BaseModel):
    message: str = Field(..., description="The message to process", max_length=1000)


@mcp.tool()
@rate_limited
@audited
async def example_tool(message: str) -> str:
    """An example enterprise tool with rate limiting and audit logging"""
    return json.dumps({
        'processed': True,
        'message': message,
        'timestamp': datetime.utcnow().isoformat()
    })


@mcp.tool()
async def health_check() -> str:
    """Health check endpoint"""
    return json.dumps({
        'status': 'healthy',
        'version': '{{version}}',
        'timestamp': datetime.utcnow().isoformat()
    })


# ===========================================
# Protected Resource Metadata (RFC 9728)
# ===========================================

PROTECTED_RESOURCE_METADATA = {
    'resource': os.getenv('RESOURCE_URL', 'https://{{projectName}}.example.com'),
    'authorization_servers': [
        os.getenv('AUTH_SERVER', 'https://auth.example.com')
    ],
    'bearer_methods_supported': ['header'],
    'resource_documentation': f'https://{{projectName}}.example.com/docs'
}


@mcp.tool()
async def get_protected_resource_metadata() -> str:
    """Return OAuth protected resource metadata per RFC 9728"""
    return json.dumps(PROTECTED_RESOURCE_METADATA)


# ===========================================
# Main
# ===========================================

if __name__ == '__main__':
    logger.info(f"Starting {{projectName}} MCP server")
    mcp.run()
