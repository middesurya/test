"""
{{projectName}} - Multi-Agent MCP Server (Python)
Orchestrator/Worker pattern with FastMCP
"""

import os
import json
import asyncio
import logging
from datetime import datetime
from typing import Any
from enum import Enum
from dataclasses import dataclass, field

from fastmcp import FastMCP
from pydantic import BaseModel, Field

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

# Initialize FastMCP server
mcp = FastMCP(
    name='{{projectName}}',
    version='{{version}}',
    description='{{projectDescription}}'
)


# ===========================================
# Task Management
# ===========================================

class TaskStatus(str, Enum):
    PENDING = 'pending'
    RUNNING = 'running'
    COMPLETED = 'completed'
    FAILED = 'failed'


@dataclass
class Task:
    id: str
    type: str
    payload: dict[str, Any]
    status: TaskStatus = TaskStatus.PENDING
    result: Any = None
    error: str | None = None
    created_at: datetime = field(default_factory=datetime.utcnow)
    completed_at: datetime | None = None


class TaskQueue:
    """Simple in-memory task queue"""

    def __init__(self):
        self.tasks: dict[str, Task] = {}
        self._counter = 0

    def create_task(self, task_type: str, payload: dict[str, Any]) -> Task:
        self._counter += 1
        task_id = f"task_{self._counter}"
        task = Task(id=task_id, type=task_type, payload=payload)
        self.tasks[task_id] = task
        return task

    def get_task(self, task_id: str) -> Task | None:
        return self.tasks.get(task_id)

    def update_task(self, task_id: str, **kwargs):
        if task_id in self.tasks:
            task = self.tasks[task_id]
            for key, value in kwargs.items():
                setattr(task, key, value)

    def get_pending_tasks(self) -> list[Task]:
        return [t for t in self.tasks.values() if t.status == TaskStatus.PENDING]


# Global task queue
task_queue = TaskQueue()


# ===========================================
# Agent Definitions
# ===========================================

class Agent:
    """Base class for agents"""

    def __init__(self, name: str):
        self.name = name

    async def process(self, task: Task) -> Any:
        raise NotImplementedError


class OrchestratorAgent(Agent):
    """Orchestrator agent that delegates work to worker agents"""

    def __init__(self):
        super().__init__('orchestrator')
        self.workers: dict[str, Agent] = {}

    def register_worker(self, task_type: str, worker: Agent):
        self.workers[task_type] = worker

    async def process(self, task: Task) -> Any:
        worker = self.workers.get(task.type)
        if not worker:
            raise ValueError(f"No worker for task type: {task.type}")

        logger.info(f"Orchestrator delegating {task.type} to {worker.name}")
        return await worker.process(task)


class DataProcessorAgent(Agent):
    """Worker agent for data processing tasks"""

    def __init__(self):
        super().__init__('data_processor')

    async def process(self, task: Task) -> dict[str, Any]:
        data = task.payload.get('data', [])
        operation = task.payload.get('operation', 'count')

        if operation == 'count':
            return {'count': len(data)}
        elif operation == 'sum':
            return {'sum': sum(data) if all(isinstance(x, (int, float)) for x in data) else 0}
        elif operation == 'transform':
            return {'transformed': [str(x).upper() for x in data]}
        else:
            return {'data': data}


class AnalysisAgent(Agent):
    """Worker agent for analysis tasks"""

    def __init__(self):
        super().__init__('analyzer')

    async def process(self, task: Task) -> dict[str, Any]:
        text = task.payload.get('text', '')
        return {
            'word_count': len(text.split()),
            'char_count': len(text),
            'line_count': len(text.split('\n'))
        }


# Initialize agents
orchestrator = OrchestratorAgent()
orchestrator.register_worker('data_process', DataProcessorAgent())
orchestrator.register_worker('analyze', AnalysisAgent())


# ===========================================
# Tools
# ===========================================

class SubmitTaskInput(BaseModel):
    task_type: str = Field(..., description="Type of task (data_process, analyze)")
    payload: dict = Field(..., description="Task payload")


@mcp.tool()
async def submit_task(task_type: str, payload: dict) -> str:
    """Submit a task for processing by worker agents"""
    task = task_queue.create_task(task_type, payload)

    # Process asynchronously
    asyncio.create_task(process_task(task.id))

    return json.dumps({
        'task_id': task.id,
        'status': task.status,
        'message': f'Task {task.id} submitted for processing'
    })


@mcp.tool()
async def get_task_status(task_id: str) -> str:
    """Get the status of a submitted task"""
    task = task_queue.get_task(task_id)

    if not task:
        return json.dumps({'error': f'Task {task_id} not found'})

    return json.dumps({
        'task_id': task.id,
        'type': task.type,
        'status': task.status,
        'result': task.result,
        'error': task.error,
        'created_at': task.created_at.isoformat(),
        'completed_at': task.completed_at.isoformat() if task.completed_at else None
    })


@mcp.tool()
async def list_agents() -> str:
    """List available worker agents"""
    return json.dumps({
        'orchestrator': orchestrator.name,
        'workers': list(orchestrator.workers.keys())
    })


async def process_task(task_id: str):
    """Background task processor"""
    task = task_queue.get_task(task_id)
    if not task:
        return

    task_queue.update_task(task_id, status=TaskStatus.RUNNING)

    try:
        result = await orchestrator.process(task)
        task_queue.update_task(
            task_id,
            status=TaskStatus.COMPLETED,
            result=result,
            completed_at=datetime.utcnow()
        )
        logger.info(f"Task {task_id} completed successfully")
    except Exception as e:
        task_queue.update_task(
            task_id,
            status=TaskStatus.FAILED,
            error=str(e),
            completed_at=datetime.utcnow()
        )
        logger.error(f"Task {task_id} failed: {e}")


# ===========================================
# Main
# ===========================================

if __name__ == '__main__':
    logger.info(f"Starting {{projectName}} Multi-Agent MCP server")
    logger.info(f"Available workers: {list(orchestrator.workers.keys())}")
    mcp.run()
